diff --git a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java
index cc23b61..4770a05 100644
--- a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java
+++ b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java
@@ -103,6 +103,7 @@ public class LocationProvider implements
             LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this);
             mGoogleApiClient.disconnect();
         }
+        connected = false;
     }
 
     @Override
@@ -116,7 +117,12 @@ public class LocationProvider implements
             mLocationCallback.handleNewLocation(location);
         }
         // Now request continuous Location Updates
-        LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest, this);
+        try {
+            LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest, this);
+        } catch (Exception e) {
+            e.printStackTrace();
+            disconnect();
+        }
     }
 
     @Override
diff --git a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java.orig b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java.orig
new file mode 100644
index 0000000..cc23b61
--- /dev/null
+++ b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java.orig
@@ -0,0 +1,163 @@
+package com.timhagn.rngloc;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.IntentSender;
+import android.location.Location;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.google.android.gms.common.ConnectionResult;
+import com.google.android.gms.common.GooglePlayServicesUtil;
+import com.google.android.gms.common.api.GoogleApiClient;
+import com.google.android.gms.location.LocationListener;
+import com.google.android.gms.location.LocationRequest;
+import com.google.android.gms.location.LocationServices;
+
+/**
+ * Created by benjakuben on 12/17/14.
+ */
+public class LocationProvider implements
+        GoogleApiClient.ConnectionCallbacks,
+        GoogleApiClient.OnConnectionFailedListener,
+        LocationListener {
+
+    /**
+     * Location Callback interface to be defined in Module
+     */
+    public abstract interface LocationCallback {
+        public abstract void handleNewLocation(Location location);
+    }
+
+    // Unique Name for Log TAG
+    public static final String TAG = LocationProvider.class.getSimpleName();
+    /*
+     * Define a request code to send to Google Play services
+     * This code is returned in Activity.onActivityResult
+     */
+    private final static int CONNECTION_FAILURE_RESOLUTION_REQUEST = 9000;
+    // Location Callback for later use
+    private LocationCallback mLocationCallback;
+    // Context for later use
+    private Context mContext;
+    // Main Google API CLient (Google Play Services API)
+    private GoogleApiClient mGoogleApiClient;
+    // Location Request for later use
+    private LocationRequest mLocationRequest;
+    // Are we Connected?
+    public Boolean connected;
+
+    public LocationProvider(Context context, LocationCallback updateCallback) {
+        // Save current Context
+        mContext = context;
+        // Save Location Callback
+        this.mLocationCallback = updateCallback;
+        // Initialize connection "state"
+        connected = false;
+
+        // First we need to check availability of play services
+        if (checkPlayServices()) {
+            mGoogleApiClient = new GoogleApiClient.Builder(context)
+                    .addConnectionCallbacks(this)
+                    .addOnConnectionFailedListener(this)
+                    .addApi(LocationServices.API)
+                    .build();
+
+            // Create the LocationRequest object
+            mLocationRequest = LocationRequest.create()
+                    .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
+                    .setInterval(10 * 1000)        // 10 seconds, in milliseconds
+                    .setFastestInterval(1000);     // 1 second, in milliseconds
+        }
+    }
+
+    /**
+     * Method to verify google play services on the device
+     * */
+    public boolean checkPlayServices() {
+        int resultCode = GooglePlayServicesUtil
+                .isGooglePlayServicesAvailable(mContext);
+        if (resultCode != ConnectionResult.SUCCESS) {
+            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {
+                Log.i(TAG, GooglePlayServicesUtil.getErrorString(resultCode));
+            } else {
+                Log.i(TAG, "This device is not supported.");
+            }
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Connects to Google Play Services - Location
+     */
+    public void connect() {
+        mGoogleApiClient.connect();
+    }
+
+    /**
+     * Disconnects to Google Play Services - Location
+     */
+    public void disconnect() {
+        if (mGoogleApiClient.isConnected()) {
+            LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this);
+            mGoogleApiClient.disconnect();
+        }
+    }
+
+    @Override
+    public void onConnected(Bundle bundle) {
+        Log.i(TAG, "Location services connected.");
+        // We are Connected!
+        connected = true;
+        // First, get Last Location and return it to Callback
+        Location location = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);
+        if (location != null) {
+            mLocationCallback.handleNewLocation(location);
+        }
+        // Now request continuous Location Updates
+        LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest, this);
+    }
+
+    @Override
+    public void onConnectionSuspended(int i) {
+        Log.i(TAG, "Location services suspended...");
+    }
+
+    @Override
+    public void onConnectionFailed(ConnectionResult connectionResult) {
+        /*
+         * Google Play services can resolve some errors it detects.
+         * If the error has a resolution, try sending an Intent to
+         * start a Google Play services activity that can resolve
+         * error.
+         */
+        if (connectionResult.hasResolution() && mContext instanceof Activity) {
+            try {
+                Activity activity = (Activity)mContext;
+                // Start an Activity that tries to resolve the error
+                connectionResult.startResolutionForResult(activity, CONNECTION_FAILURE_RESOLUTION_REQUEST);
+            /*
+             * Thrown if Google Play services canceled the original
+             * PendingIntent
+             */
+            } catch (IntentSender.SendIntentException e) {
+                // Log the error
+                e.printStackTrace();
+            }
+        } else {
+            /*
+             * If no resolution is available, display a dialog to the
+             * user with the error.
+             */
+            Log.i(TAG, "Location services connection failed with code " + connectionResult.getErrorCode());
+        }
+    }
+
+    @Override
+    public void onLocationChanged(Location location) {
+        Log.i(TAG, "Location Changed!");
+        // Callback as defined in Module.
+        mLocationCallback.handleNewLocation(location);
+    }
+}
diff --git a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java.rej b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java.rej
new file mode 100644
index 0000000..b34ae79
--- /dev/null
+++ b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/LocationProvider.java.rej
@@ -0,0 +1,172 @@
+***************
+*** 0 ****
+--- 1,169 ----
++ package com.timhagn.rngloc;
++ 
++ import android.app.Activity;
++ import android.content.Context;
++ import android.content.IntentSender;
++ import android.location.Location;
++ import android.os.Bundle;
++ import android.util.Log;
++ 
++ import com.google.android.gms.common.ConnectionResult;
++ import com.google.android.gms.common.GooglePlayServicesUtil;
++ import com.google.android.gms.common.api.GoogleApiClient;
++ import com.google.android.gms.location.LocationListener;
++ import com.google.android.gms.location.LocationRequest;
++ import com.google.android.gms.location.LocationServices;
++ 
++ /**
++  * Created by benjakuben on 12/17/14.
++  */
++ public class LocationProvider implements
++         GoogleApiClient.ConnectionCallbacks,
++         GoogleApiClient.OnConnectionFailedListener,
++         LocationListener {
++ 
++     /**
++      * Location Callback interface to be defined in Module
++      */
++     public abstract interface LocationCallback {
++         public abstract void handleNewLocation(Location location);
++     }
++ 
++     // Unique Name for Log TAG
++     public static final String TAG = LocationProvider.class.getSimpleName();
++     /*
++      * Define a request code to send to Google Play services
++      * This code is returned in Activity.onActivityResult
++      */
++     private final static int CONNECTION_FAILURE_RESOLUTION_REQUEST = 9000;
++     // Location Callback for later use
++     private LocationCallback mLocationCallback;
++     // Context for later use
++     private Context mContext;
++     // Main Google API CLient (Google Play Services API)
++     private GoogleApiClient mGoogleApiClient;
++     // Location Request for later use
++     private LocationRequest mLocationRequest;
++     // Are we Connected?
++     public Boolean connected;
++ 
++     public LocationProvider(Context context, LocationCallback updateCallback) {
++         // Save current Context
++         mContext = context;
++         // Save Location Callback
++         this.mLocationCallback = updateCallback;
++         // Initialize connection "state"
++         connected = false;
++ 
++         // First we need to check availability of play services
++         if (checkPlayServices()) {
++             mGoogleApiClient = new GoogleApiClient.Builder(context)
++                     .addConnectionCallbacks(this)
++                     .addOnConnectionFailedListener(this)
++                     .addApi(LocationServices.API)
++                     .build();
++ 
++             // Create the LocationRequest object
++             mLocationRequest = LocationRequest.create()
++                     .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
++                     .setInterval(10 * 1000)        // 10 seconds, in milliseconds
++                     .setFastestInterval(1000);     // 1 second, in milliseconds
++         }
++     }
++ 
++     /**
++      * Method to verify google play services on the device
++      * */
++     public boolean checkPlayServices() {
++         int resultCode = GooglePlayServicesUtil
++                 .isGooglePlayServicesAvailable(mContext);
++         if (resultCode != ConnectionResult.SUCCESS) {
++             if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {
++                 Log.i(TAG, GooglePlayServicesUtil.getErrorString(resultCode));
++             } else {
++                 Log.i(TAG, "This device is not supported.");
++             }
++             return false;
++         }
++         return true;
++     }
++ 
++     /**
++      * Connects to Google Play Services - Location
++      */
++     public void connect() {
++         mGoogleApiClient.connect();
++     }
++ 
++     /**
++      * Disconnects to Google Play Services - Location
++      */
++     public void disconnect() {
++         if (mGoogleApiClient.isConnected()) {
++             LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this);
++             mGoogleApiClient.disconnect();
++         }
++         connected = false;
++     }
++ 
++     @Override
++     public void onConnected(Bundle bundle) {
++         Log.i(TAG, "Location services connected.");
++         // We are Connected!
++         connected = true;
++         // First, get Last Location and return it to Callback
++         Location location = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);
++         if (location != null) {
++             mLocationCallback.handleNewLocation(location);
++         }
++         // Now request continuous Location Updates
++         try {
++             LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest, this);
++         } catch (Exception e) {
++             e.printStackTrace();
++             disconnect();
++         }
++     }
++ 
++     @Override
++     public void onConnectionSuspended(int i) {
++         Log.i(TAG, "Location services suspended...");
++     }
++ 
++     @Override
++     public void onConnectionFailed(ConnectionResult connectionResult) {
++         /*
++          * Google Play services can resolve some errors it detects.
++          * If the error has a resolution, try sending an Intent to
++          * start a Google Play services activity that can resolve
++          * error.
++          */
++         if (connectionResult.hasResolution() && mContext instanceof Activity) {
++             try {
++                 Activity activity = (Activity)mContext;
++                 // Start an Activity that tries to resolve the error
++                 connectionResult.startResolutionForResult(activity, CONNECTION_FAILURE_RESOLUTION_REQUEST);
++             /*
++              * Thrown if Google Play services canceled the original
++              * PendingIntent
++              */
++             } catch (IntentSender.SendIntentException e) {
++                 // Log the error
++                 e.printStackTrace();
++             }
++         } else {
++             /*
++              * If no resolution is available, display a dialog to the
++              * user with the error.
++              */
++             Log.i(TAG, "Location services connection failed with code " + connectionResult.getErrorCode());
++         }
++     }
++ 
++     @Override
++     public void onLocationChanged(Location location) {
++         Log.i(TAG, "Location Changed!");
++         // Callback as defined in Module.
++         mLocationCallback.handleNewLocation(location);
++     }
++ }
diff --git a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java
index 137fef2..daab780 100644
--- a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java
+++ b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java
@@ -42,14 +42,34 @@ public class RNGLocationModule extends ReactContextBaseJavaModule implements Loc
 
         // Check if all went well and the Google Play Service are available...
         if (!mLocationProvider.checkPlayServices()) {
+            mLocationProvider = null;
             Log.i(TAG, "Location Provider not available...");
         } else {
             // Connect to Play Services
-            mLocationProvider.connect();
+            //mLocationProvider.connect();
             Log.i(TAG, "Location Provider successfully created.");
         }
     }
 
+    @ReactMethod
+    public boolean available() {
+        if (mLocationProvider != null) return true;
+        return false;
+    }
+
+    @ReactMethod
+    public void disconnect() {
+        if (mLocationProvider != null && mLocationProvider.connected) {
+            mLocationProvider.disconnect();
+        }
+    }
+
+    @ReactMethod
+    public void reconnect() {
+        if (mLocationProvider != null && !mLocationProvider.connected) {
+            mLocationProvider.connect();
+        }
+    }
 
     @Override
     public String getName() {
diff --git a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java.orig b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java.orig
new file mode 100644
index 0000000..137fef2
--- /dev/null
+++ b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java.orig
@@ -0,0 +1,122 @@
+package com.timhagn.rngloc;
+
+import android.location.Location;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.facebook.react.bridge.Arguments;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.WritableMap;
+import com.facebook.react.modules.core.DeviceEventManagerModule;
+
+/**
+ * Created by hagn on 11/5/15.
+ *
+ * Simple React Native Module for accessing Android Location Services by way of Google Play Services
+ *
+ */
+public class RNGLocationModule extends ReactContextBaseJavaModule implements LocationProvider.LocationCallback {
+    // React Class Name as called from JS
+    public static final String REACT_CLASS = "RNGLocation";
+    // Unique Name for Log TAG
+    public static final String TAG = RNGLocationModule.class.getSimpleName();
+    // Save last Location Provided
+    private Location mLastLocation;
+    // The Google Play Services Location Provider
+    private LocationProvider mLocationProvider;
+    //The React Native Context
+    ReactApplicationContext mReactContext;
+
+
+    // Constructor Method as called in Package
+    public RNGLocationModule(ReactApplicationContext reactContext) {
+        super(reactContext);
+        // Save Context for later use
+        mReactContext = reactContext;
+
+        // Get Location Provider from Google Play Services
+        mLocationProvider = new LocationProvider(mReactContext.getApplicationContext(), this);
+
+        // Check if all went well and the Google Play Service are available...
+        if (!mLocationProvider.checkPlayServices()) {
+            Log.i(TAG, "Location Provider not available...");
+        } else {
+            // Connect to Play Services
+            mLocationProvider.connect();
+            Log.i(TAG, "Location Provider successfully created.");
+        }
+    }
+
+
+    @Override
+    public String getName() {
+        return REACT_CLASS;
+    }
+
+    /*
+     * Location Callback as defined by LocationProvider
+     */
+    @Override
+    public void handleNewLocation(Location location) {
+        if (location != null) {
+            mLastLocation = location;
+            Log.i(TAG, "New Location..." + location.toString());
+            getLocation();
+        }
+    }
+
+    /*
+     * Location Provider as called by JS
+     */
+    @ReactMethod
+    public void getLocation() {
+        if (mLastLocation != null) {
+            try {
+                double Longitude;
+                double Latitude;
+
+                // Receive Longitude / Latitude from (updated) Last Location
+                Longitude = mLastLocation.getLongitude();
+                Latitude = mLastLocation.getLatitude();
+
+                Log.i(TAG, "Got new location. Lng: " + Longitude+" Lat: " + Latitude);
+
+                // Create Map with Parameters to send to JS
+                WritableMap params = Arguments.createMap();
+                params.putDouble("Longitude", Longitude);
+                params.putDouble("Latitude", Latitude);
+
+                // Send Event to JS to update Location
+                sendEvent(mReactContext, "updateLocation", params);
+            } catch (Exception e) {
+                e.printStackTrace();
+                Log.i(TAG, "Location services disconnected.");
+            }
+        }
+    }
+
+    /*
+     * Internal function for communicating with JS
+     */
+    private void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) {
+        if (reactContext.hasActiveCatalystInstance()) {
+            reactContext
+                    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
+                    .emit(eventName, params);
+        } else {
+            Log.i(TAG, "Waiting for CatalystInstance...");
+        }
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+        // If Location Provider is connected, disconnect.
+        if (mLocationProvider != null && mLocationProvider.connected) {
+            mLocationProvider.disconnect();
+        }
+    }
+}
diff --git a/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java.rej b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java.rej
new file mode 100644
index 0000000..2cd4419
--- /dev/null
+++ b/node_modules/react-native-google-location/android/app/src/main/java/com/timhagn/rngloc/RNGLocationModule.java.rej
@@ -0,0 +1,145 @@
+***************
+*** 0 ****
+--- 1,142 ----
++ package com.timhagn.rngloc;
++ 
++ import android.location.Location;
++ import android.support.annotation.Nullable;
++ import android.util.Log;
++ 
++ import com.facebook.react.bridge.Arguments;
++ import com.facebook.react.bridge.ReactApplicationContext;
++ import com.facebook.react.bridge.ReactContext;
++ import com.facebook.react.bridge.ReactContextBaseJavaModule;
++ import com.facebook.react.bridge.ReactMethod;
++ import com.facebook.react.bridge.WritableMap;
++ import com.facebook.react.modules.core.DeviceEventManagerModule;
++ 
++ /**
++  * Created by hagn on 11/5/15.
++  *
++  * Simple React Native Module for accessing Android Location Services by way of Google Play Services
++  *
++  */
++ public class RNGLocationModule extends ReactContextBaseJavaModule implements LocationProvider.LocationCallback {
++     // React Class Name as called from JS
++     public static final String REACT_CLASS = "RNGLocation";
++     // Unique Name for Log TAG
++     public static final String TAG = RNGLocationModule.class.getSimpleName();
++     // Save last Location Provided
++     private Location mLastLocation;
++     // The Google Play Services Location Provider
++     private LocationProvider mLocationProvider;
++     //The React Native Context
++     ReactApplicationContext mReactContext;
++ 
++ 
++     // Constructor Method as called in Package
++     public RNGLocationModule(ReactApplicationContext reactContext) {
++         super(reactContext);
++         // Save Context for later use
++         mReactContext = reactContext;
++ 
++         // Get Location Provider from Google Play Services
++         mLocationProvider = new LocationProvider(mReactContext.getApplicationContext(), this);
++ 
++         // Check if all went well and the Google Play Service are available...
++         if (!mLocationProvider.checkPlayServices()) {
++             mLocationProvider = null;
++             Log.i(TAG, "Location Provider not available...");
++         } else {
++             // Connect to Play Services
++             //mLocationProvider.connect();
++             Log.i(TAG, "Location Provider successfully created.");
++         }
++     }
++ 
++     @ReactMethod
++     public boolean available() {
++         if (mLocationProvider != null) return true;
++         return false;
++     }
++ 
++     @ReactMethod
++     public void disconnect() {
++         if (mLocationProvider != null && mLocationProvider.connected) {
++             mLocationProvider.disconnect();
++         }
++     }
++ 
++     @ReactMethod
++     public void reconnect() {
++         if (mLocationProvider != null && !mLocationProvider.connected) {
++             mLocationProvider.connect();
++         }
++     }
++ 
++     @Override
++     public String getName() {
++         return REACT_CLASS;
++     }
++ 
++     /*
++      * Location Callback as defined by LocationProvider
++      */
++     @Override
++     public void handleNewLocation(Location location) {
++         if (location != null) {
++             mLastLocation = location;
++             Log.i(TAG, "New Location..." + location.toString());
++             getLocation();
++         }
++     }
++ 
++     /*
++      * Location Provider as called by JS
++      */
++     @ReactMethod
++     public void getLocation() {
++         if (mLastLocation != null) {
++             try {
++                 double Longitude;
++                 double Latitude;
++ 
++                 // Receive Longitude / Latitude from (updated) Last Location
++                 Longitude = mLastLocation.getLongitude();
++                 Latitude = mLastLocation.getLatitude();
++ 
++                 Log.i(TAG, "Got new location. Lng: " + Longitude+" Lat: " + Latitude);
++ 
++                 // Create Map with Parameters to send to JS
++                 WritableMap params = Arguments.createMap();
++                 params.putDouble("Longitude", Longitude);
++                 params.putDouble("Latitude", Latitude);
++ 
++                 // Send Event to JS to update Location
++                 sendEvent(mReactContext, "updateLocation", params);
++             } catch (Exception e) {
++                 e.printStackTrace();
++                 Log.i(TAG, "Location services disconnected.");
++             }
++         }
++     }
++ 
++     /*
++      * Internal function for communicating with JS
++      */
++     private void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) {
++         if (reactContext.hasActiveCatalystInstance()) {
++             reactContext
++                     .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
++                     .emit(eventName, params);
++         } else {
++             Log.i(TAG, "Waiting for CatalystInstance...");
++         }
++     }
++ 
++     @Override
++     protected void finalize() throws Throwable {
++         super.finalize();
++         // If Location Provider is connected, disconnect.
++         if (mLocationProvider != null && mLocationProvider.connected) {
++             mLocationProvider.disconnect();
++         }
++     }
++ }
